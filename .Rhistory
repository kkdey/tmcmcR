L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=100,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
Mult_Mattingly[2,l,,] <- rmc3(pdf,beta_set=beta_set, base=base, scale=1, cycle=100,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
cat("We are at iter:",l, "\n")
}
target_pdf <- pdf
if(is.null(burn_in)) burn_in <- nsamples/3;
if(is.null(scale)) stop("scale value not provided")
if(is.null(beta_set)) stop("set of inverse temperatures not provided")
base
rtmc3_chains <- vector("list", length(beta_set));
num = 1
while(num <= nsamples){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
num <- 1
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
if(num %% cycle ==0)
{
if(swap_adjacent)
{
index_select <- sample(2:length(beta_set), 1);
indices <- c(index_select-1, index_select);
}
if(!swap_adjacent)
{
indices <- sample(1:length(beta_set), 2);
}
chain1 <- rtmc3_chains[[k]][indices[1],];
chain2 <- rtmc3_chains[[k-1]][indices[2],];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[indices[1]]][num,] <- chain2;
rtmc3_chains[[indices[2]]][num,] <- chain1;
}
}
while(num <= nsamples){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
if(num %% cycle ==0)
{
if(swap_adjacent)
{
index_select <- sample(2:length(beta_set), 1);
indices <- c(index_select-1, index_select);
}
if(!swap_adjacent)
{
indices <- sample(1:length(beta_set), 2);
}
chain1 <- rtmc3_chains[[k]][indices[1],];
chain2 <- rtmc3_chains[[k-1]][indices[2],];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[indices[1]]][num,] <- chain2;
rtmc3_chains[[indices[2]]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num,"\n");
}
}
num <- num + 1;
}
swap_adjacent=TRUE
while(num <= nsamples){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
if(num %% cycle ==0)
{
if(swap_adjacent)
{
index_select <- sample(2:length(beta_set), 1);
indices <- c(index_select-1, index_select);
}
if(!swap_adjacent)
{
indices <- sample(1:length(beta_set), 2);
}
chain1 <- rtmc3_chains[[k]][indices[1],];
chain2 <- rtmc3_chains[[k-1]][indices[2],];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[indices[1]]][num,] <- chain2;
rtmc3_chains[[indices[2]]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num,"\n");
}
}
num <- num + 1;
}
posterior_mean <- apply(rtmc3_chains[[1]][round(burn_in):nsamples,], 2, mean);
ll <- list("chain_set"=rtmc3_chains,"post.mean"=posterior_mean);
ll$chain_set[[1]]
dim(ll$chain_set[[1]])
ll$chain_set[[1]][1,]
num
nsamples
dim(ll$chain_set[[1]])
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=10;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 2000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
l <- 1
Mult_Mattingly[1,l,,] <- rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
Mult_Mattingly[2,l,,] <- rmc3(pdf,beta_set=beta_set, base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=10;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 2000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
Mult_Mattingly[2,l,,] <- rmc3(pdf,beta_set=beta_set, base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
cat("We are at iter:",l, "\n")
}
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
for(d in 1:10)
{
for(n in 1:nsamples)
{
simulate.vec <- rnorm(L,mu_target[d],Sigma_target[d,d]/(sqrt(2*Sigma_target[d,d]^2+1)));
KSval1[n]=ks.test(Mult_Mattingly[1,,n,d],simulate.vec)$statistic;
KSval2[n]=ks.test(Mult_Mattingly[2,,n,d],simulate.vec)$statistic;
}
plot(1:nsamples,KSval1,col="red",type="l",lwd=1,pch=2,xlab="",ylab="")
lines(1:nsamples,KSval2,col="blue",lwd=1,pch=3)
title(xlab="Time step of run");
title(ylab="KS test distance");
title(main="KS plot comparison");
legend("topright",c("RTMC3","RMC3"),fill=c("red","blue"),border="black");
}
source('~/Documents/tmcmcR/R/select_inverse_temp.R')
pdf_component <- function(x) return dnorm(x,0,1,log=TRUE)
pdf_component <- function(x) {return dnorm(x,0,1,log=TRUE)}
pdf_component =function(x) {return dnorm(x,0,1,log=TRUE)}
dnorm(0,0,1,log=TRUE)
pdf_component <- function(x) {return dnorm(x,0,1,log=TRUE)}
pdf_component <- function(x) return dnorm(x,0,1,log=TRUE)
pdf_component <- function(x) { out <- dnorm(x,0,1,log=TRUE); return(out)}
temp <- select_inverse_temp(pdf_component, minbeta=0.05, L_iter =50, sim_method = "RWMH", inv_temp_scheme="randomized")
devtools::document()
source('~/Documents/tmcmcR/R/rand_generate.R')
beta_array <- 1;
counter <- 1
current_beta = 1;
minbeta=0.05
L_iter =50
sim_method="RWMH"
inv_temp_scheme="randomized"
beta_array <- 1;
counter <- 1
current_beta = 1;
rho <- 0;
l <- 1
temp_beta <- current_beta * (1/(1 + exp(rho)));
pdf_1 <- function(x, current_beta = current_beta) { return(pdf_component(x)*current_beta)};
pdf_2 <- function(x, temp_beta=temp_beta) { return(pdf_component(x)*temp_beta)};
x_curr <- .rand_generate(pdf_1, method=sim_method);
x_curr <- .rand_generate(pdf_1, method="RWMH");
base <- 0
scale <- 1
nsamples <- 1000;
if(method=="TMCMC")
out <- tmcmc_metrop(unipdf, scale, base, nsamples)$chain[1000,];
if(method=="RMWH")
out <- rwmh_metrop(unipdf, scale, base, nsamples)$chain[1000,];
method="RWMH"
base <- 0
scale <- 1
nsamples <- 1000;
if(method=="TMCMC")
out <- tmcmc_metrop(unipdf, scale, base, nsamples)$chain[1000,];
if(method=="RMWH")
out <- rwmh_metrop(unipdf, scale, base, nsamples)$chain[1000,];
out
out <- tmcmc_metrop(unipdf, scale, base, nsamples)$chain[1000,];
unipdf <- pdf_1
out <- tmcmc_metrop(unipdf, scale, base, nsamples)$chain[1000,];
base <- 0
scale <- 1
nsamples <- 1000;
if(method=="TMCMC")
out <- tmcmc_metrop(unipdf, scale, base, nsamples)$chain[1000,];
if(method=="RMWH")
out <- rwmh_metrop(unipdf, scale, base, nsamples)$chain[1000,];
out
out <- tmcmc_metrop(unipdf, scale, base, nsamples)$chain[1000,];
unipdf
tmcmc_metrop(unipdf, scale, base, nsamples)
tmcmc_metrop(unipdf, scale, base, nsamples)
tmcmc_metrop(unipdf, scale, base, nsamples)
library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
Mult_Mattingly[2,l,,] <- rwmh_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
cat("We are at iter:",l, "\n")
}
unipdf <- function(x) { return dnorm(x,0,1,log=TRUE)}
unipdf <- function(x) return dnorm(x,0,1,log=TRUE)
unipdf <- function(x) return (dnorm(x,0,1,log=TRUE))
unipdf(0)
unipdf(0.1)
unipdf(100)
rm(list=ls())
library(tmcmcR)
unipdf <- function(x) return (dnorm(x,0,1,log=TRUE))
d <- 1
nsamples <- 5000;
base <- 0
temp <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
temp <- tmcmc_metrop(unipdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
length(base)
devtools::document()
unipdf <- function(x) return (dnorm(x,0,1,log=TRUE))
d <- 1
nsamples <- 5000;
base <- 0
temp <- tmcmc_metrop(unipdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
temp
dim(temp)
temp1 <- .rand_generate(unipdf, method="TMCMC")
temp1 <- .rand_generate(unipdf, method="TMCMC")
select_inverse_temp(unipdf, minbeta=0.05, L_iter =50, sim_method="TMCMC", inv_temp_scheme="fixed")
temp2 <- select_inverse_temp(unipdf, minbeta=0.05, L_iter =50, sim_method="TMCMC", inv_temp_scheme="fixed")
beta_array <- 1;
counter <- 1
current_beta = 1;
rho <- 0;
current_beta
minbeta
minbeta <- 0.05
temp_beta <- current_beta * (1/(1 + exp(rho)));
pdf_1 <- function(x, current_beta = current_beta) { return(pdf_component(x)*current_beta)};
pdf_2 <- function(x, temp_beta=temp_beta) { return(pdf_component(x)*temp_beta)};
pdf_1(0)
pdf_component <- unipdf
pdf_1(0)
temp_beta
pdf_1 <- function(x) { return(pdf_component(x)*current_beta)};
pdf_2 <- function(x) { return(pdf_component(x)*temp_beta)};
pdf_1(0)
x_curr <- .rand_generate(pdf_1, method=sim_method);
sim_method="TMCMC"
x_curr <- .rand_generate(pdf_1, method=sim_method);
x_temp <- .rand_generate(pdf_2, method=sim_method);
B <- -(temp_beta - current_beta)* (pdf_2(x_temp,temp_beta) - pdf1(x_curr, current_beta));
B <- -(temp_beta - current_beta)* (pdf_2(x_temp) - pdf_1(x_curr));
alpha <- min(1, exp(B));
temp2 <- select_inverse_temp(unipdf, minbeta=0.05, L_iter =50, sim_method="TMCMC", inv_temp_scheme="fixed")
devtools::document()
install_github('kkdey/tmcmcR')
library(tmcmcR)
unipdf <- function(x) return (dnorm(x,0,1,log=TRUE))
d <- 1
nsamples <- 5000;
base <- 0
temp <- tmcmc_metrop(unipdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
temp1 <- .rand_generate(unipdf, method="TMCMC")
temp2 <- select_inverse_temp(unipdf, minbeta=0.05, L_iter =50, sim_method="TMCMC", inv_temp_scheme="fixed")
temp2
install_github('kkdey/tmcmcR')
library(tmcmcR)
unipdf <- function(x) return (dnorm(x,0,1,log=TRUE))
d <- 1
nsamples <- 5000;
base <- 0
temp <- tmcmc_metrop(unipdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
temp1 <- .rand_generate(unipdf, method="TMCMC")
temp2 <- select_inverse_temp(unipdf, minbeta=0.05, L_iter =50, sim_method="TMCMC", inv_temp_scheme="fixed")
temp2
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(tmcmcR)
library(tmcmcR)
install.packages("tmcmcR")
install.packages("tmcmcR")
install.packages(tmcmcR)
install_github('kkdey/tmcmcR')
library(devtools)
install_github('kkdey/tmcmcR')
ceil(0.04)
ceiling(0.04)
library(tmcmcR)
install_github('kkdey/tmcmcR')
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=10;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 2000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
Mult_Mattingly[2,l,,] <- rmc3(pdf,beta_set=beta_set, base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
cat("We are at iter:",l, "\n")
}
library(tmcmcR)
devtools::release()
version()
sessionInfo()
devtools::release()
install.packages("devtools")
library(devtools)
devtools::release()
devtools::release()
devtools::release()
library(knitr)
install.packages("knitr")
library(knitr)
devtools::release()
devtools::release()
install.packages("mvtnorm")
library(mvtnorm)
devtools::release()
library(tmcmcR)
?rwmh_metrop
d=50;  ##  dimension of the simulated variable
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1); ## the starting point generated independently from N(0,1)
system.time(out_rwmh <- rwmh_metrop(pdf,base=base, scale=1,nsamples=5000, verb=FALSE))
system.time(out_tmcmc <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000, verb=FALSE))
install_github('kkdey/tmcmcR')
library(tmcmcR)
system.time(out_rwmh <- rwmh_metrop(pdf,base=base, scale=1,nsamples=5000, verb=FALSE))
rwmh_metrop(pdf,base=base, scale=1,nsamples=5000, verb=FALSE)
rm(list=ls())
rwmh_metrop(pdf,base=base, scale=1,nsamples=5000, verb=FALSE)
install_github('kkdey/tmcmcR')
library(tmcmcR)
?tmcmc_metrop
