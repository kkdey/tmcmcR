library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
nsamples=10000;##  sample size in eahc iteration/ replication
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mattingly_matrix <- 1000*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
nsamples=10000;##  sample size in eahc iteration/ replication
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mattingly_matrix <- 1000*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
out <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)
out
library(tmcmcR)
library(tmcmcR)
library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
Mult_Mattingly[2,l,,] <- rwmh_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
paste("We are at iter:",l)
}
KSval_TMCMC=array(0,nsamples);
KSval_MCMC=array(0,nsamples);
for(d in 1:40)
{
for(n in 1:nsamples)
{
simulate.vec <- rnorm(L,mu_target[d],Sigma_target[d,d]/(sqrt(2*Sigma_target[d,d]^2+1)));
KSval_TMCMC[n]=ks.test(Mult_Mattingly[2,,n,d],simulate.vec)$statistic;
KSval_MCMC[n]=ks.test(Mult_Mattingly[1,,n,d],simulate.vec)$statistic;
}
plot(1:nsamples,KSval_TMCMC,col="red",type="l",lwd=1,pch=2,xlab="",ylab="")
lines(1:nsamples,KSval_MCMC,col="blue",lwd=1,pch=3)
title(xlab="Time step of run");
title(ylab="KS test distance");
title(main="KS plot comparison");
legend("topright",c("TMCMC","RWMH"),fill=c("red","blue"),border="black");
}
nsamples
dim(Mult_Mattingly[1,1,,])
library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
Mult_Mattingly[2,l,,] <- rwmh_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
cat("We are at iter:",l)
}
KSval_TMCMC=array(0,nsamples);
KSval_MCMC=array(0,nsamples);
for(d in 1:40)
{
for(n in 1:nsamples)
{
simulate.vec <- rnorm(L,mu_target[d],Sigma_target[d,d]/(sqrt(2*Sigma_target[d,d]^2+1)));
KSval_TMCMC[n]=ks.test(Mult_Mattingly[1,,n,d],simulate.vec)$statistic;
KSval_MCMC[n]=ks.test(Mult_Mattingly[2,,n,d],simulate.vec)$statistic;
}
plot(1:nsamples,KSval_TMCMC,col="red",type="l",lwd=1,pch=2,xlab="",ylab="")
lines(1:nsamples,KSval_MCMC,col="blue",lwd=1,pch=3)
title(xlab="Time step of run");
title(ylab="KS test distance");
title(main="KS plot comparison");
legend("topright",c("TMCMC","RWMH"),fill=c("red","blue"),border="black");
}
library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, a_rama = 1, b_rama=1, method="Rama")$chain
cat("We are at iter:",l, "\n")
}
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, a_rama = 1, b_rama=1, method="Rama")$chain
cat("We are at iter:",l, "\n")
}
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
KSval3=array(0,nsamples);
install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, a_rama = 1, b_rama=1, method="Rama")$chain
cat("We are at iter:",l, "\n")
}
devtools::document()
install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, a_rama = 1, b_rama=1, method="Rama")$chain
cat("We are at iter:",l, "\n")
}
l
taget_pdf <- pdf
nsamples <- 5000
def.scale =1
scale <- def.scale;
chain <- matrix(0, nsamples, length(base))
chain[1,] <- base;
num=2;
num <- 1
store_eps <- array(0, nsamples)
store_eps[1] <- 0;
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
out <- tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)
target_pdf <- pdf
out <- tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)
chain
eps
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE)
out <- tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)
num
num <- 2
out <- tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)
chain[1,]
2>3
as.numeric(2>3)
as.numeric(2<3)
devtools::document()
install_github('kkdey/tmcmcR')
library(devtools)
install_github('kkdey/tmcmcR')
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, a_rama = 1, b_rama=1, method="Rama")$chain
cat("We are at iter:",l, "\n")
}
library(devtools)
install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, a_rama = 1, b_rama=1, method="Rama")$chain
cat("We are at iter:",l, "\n")
}
warnings()
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
KSval3=array(0,nsamples);
for(d in 1:40)
{
for(n in 1:nsamples)
{
simulate.vec <- rnorm(L,mu_target[d],Sigma_target[d,d]/(sqrt(2*Sigma_target[d,d]^2+1)));
KSval1[n]=ks.test(Mult_Mattingly[1,,n,d],simulate.vec)$statistic;
KSval2[n]=ks.test(Mult_Mattingly[2,,n,d],simulate.vec)$statistic;
KSval3[n]=ks.test(Mult_Mattingly[3,,n,d],simulate.vec)$statistic;
}
plot(1:nsamples,KSval1,col="red",type="l",lwd=1,pch=2,xlab="",ylab="")
lines(1:nsamples,KSval2,col="blue",lwd=1,pch=3)
lines(1:nsamples,KSval3,col="green",lwd=1,pch=3)
title(xlab="Time step of run");
title(ylab="KS test distance");
title(main="KS plot comparison");
legend("topright",c("Atchade","Haario", "Rama"),fill=c("red","blue","green"),border="black");
}
l <- 1
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade")$chain;
Mult_Mattingly[1,l,,]
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario")$chain;
Mult_Mattingly[2,l,,]
install_github('kkdey/tmcmcR')
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=10; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade", verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario", verb=FALSE)$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Rama", verb=FALSE)$chain
cat("We are at iter:",l, "\n")
}
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
KSval3=array(0,nsamples);
for(d in 1:40)
{
for(n in 1:nsamples)
{
simulate.vec <- rnorm(L,mu_target[d],Sigma_target[d,d]/(sqrt(2*Sigma_target[d,d]^2+1)));
KSval1[n]=ks.test(Mult_Mattingly[1,,n,d],simulate.vec)$statistic;
KSval2[n]=ks.test(Mult_Mattingly[2,,n,d],simulate.vec)$statistic;
KSval3[n]=ks.test(Mult_Mattingly[3,,n,d],simulate.vec)$statistic;
}
plot(1:nsamples,KSval1,col="red",type="l",lwd=1,pch=2,xlab="",ylab="")
lines(1:nsamples,KSval2,col="blue",lwd=1,pch=3)
lines(1:nsamples,KSval3,col="green",lwd=1,pch=3)
title(xlab="Time step of run");
title(ylab="KS test distance");
title(main="KS plot comparison");
legend("topright",c("Atchade","Haario", "Rama"),fill=c("red","blue","green"),border="black");
}
n
d
Mult_Mattingly[3, , n, d]
Mult_Mattingly[3,1,,]
devtools
devtools::document()
install_github('kkdey/tmcmcR')
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=10; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade", verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Haario", verb=FALSE)$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Rama", verb=FALSE)$chain
cat("We are at iter:",l, "\n")
}
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
KSval3=array(0,nsamples);
for(d in 1:40)
{
for(n in 1:nsamples)
{
simulate.vec <- rnorm(L,mu_target[d],Sigma_target[d,d]/(sqrt(2*Sigma_target[d,d]^2+1)));
KSval1[n]=ks.test(Mult_Mattingly[1,,n,d],simulate.vec)$statistic;
KSval2[n]=ks.test(Mult_Mattingly[2,,n,d],simulate.vec)$statistic;
KSval3[n]=ks.test(Mult_Mattingly[3,,n,d],simulate.vec)$statistic;
}
plot(1:nsamples,KSval1,col="red",type="l",lwd=1,pch=2,xlab="",ylab="")
lines(1:nsamples,KSval2,col="blue",lwd=1,pch=3)
lines(1:nsamples,KSval3,col="green",lwd=1,pch=3)
title(xlab="Time step of run");
title(ylab="KS test distance");
title(main="KS plot comparison");
legend("topright",c("Atchade","Haario", "Rama"),fill=c("red","blue","green"),border="black");
}
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=40; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade", verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="SCAM", verb=FALSE)$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Rama", verb=FALSE)$chain
cat("We are at iter:",l, "\n")
}
rm(list=ls())
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Atchade", verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="SCAM", verb=FALSE)$chain;
Mult_Mattingly[3,l,,] <- adapt_tmcmc_metrop(pdf,base=base, nsamples=5000, method="Rama", verb=FALSE)$chain
cat("We are at iter:",l, "\n")
}
