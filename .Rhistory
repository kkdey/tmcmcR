library(tmcmcR)
devtools::document()
mclapply.hack(1:4 function(x) return(x^2))
mclapply.hack(1:4, function(x) return(x^2))
devtools::document()
library(tmcmcR)
mclapply.hack(1:4, function(x) return(x^2))
rm(mclapply.hack())
library(tmcmcR)
mclapply.hack(1:4, function(x) return(x^2))
devtools::document()
library(tmcmcR)
mclapply.hack <- function(...) {
## Create a cluster
## ... How many workers do you need?
## ... N.B. list(...)[[1]] returns the first
##          argument passed to the function. In
##          this case it is the list to iterate over
size.of.list <- length(list(...)[[1]])
cl <- makeCluster( min(size.of.list, detectCores()) )
## Find out the names of the loaded packages
loaded.package.names <- c(
## Base packages
sessionInfo()$basePkgs,
## Additional packages
names( sessionInfo()$otherPkgs ))
## N.B. tryCatch() allows us to properly shut down the
##      cluster if an error in our code halts execution
##      of the function. For details see: help(tryCatch)
tryCatch( {
## Copy over all of the objects within scope to
## all clusters.
##
## The approach is as follows: Beginning with the
## current environment, copy over all objects within
## the environment to all clusters, and then repeat
## the process with the parent environment.
##
this.env <- environment()
while( identical( this.env, globalenv() ) == FALSE ) {
clusterExport(cl,
ls(all.names=TRUE, env=this.env),
envir=this.env)
this.env <- parent.env(environment())
}
## repeat for the global environment
clusterExport(cl,
ls(all.names=TRUE, env=globalenv()),
envir=globalenv())
## Load the libraries on all the clusters
## N.B. length(cl) returns the number of clusters
parLapply( cl, 1:length(cl), function(xx){
lapply(loaded.package.names, function(yy) {
## N.B. the character.only option of
##      require() allows you to give the
##      name of a package as a string.
require(yy , character.only=TRUE)})
})
## Run the lapply in parallel
return( parLapply( cl, ...) )
}, finally = {
## Stop the cluster
stopCluster(cl)
})
}
mclapply.hack(1:4, function(x) return(x^2))
rm(list=ls())
mclapply.hack <- function(...) {
## Create a cluster
## ... How many workers do you need?
## ... N.B. list(...)[[1]] returns the first
##          argument passed to the function. In
##          this case it is the list to iterate over
size.of.list <- length(list(...)[[1]])
cl <- makeCluster( min(size.of.list, detectCores()) )
## Find out the names of the loaded packages
loaded.package.names <- c(
## Base packages
sessionInfo()$basePkgs,
## Additional packages
names( sessionInfo()$otherPkgs ))
## N.B. tryCatch() allows us to properly shut down the
##      cluster if an error in our code halts execution
##      of the function. For details see: help(tryCatch)
tryCatch( {
## Copy over all of the objects within scope to
## all clusters.
##
## The approach is as follows: Beginning with the
## current environment, copy over all objects within
## the environment to all clusters, and then repeat
## the process with the parent environment.
##
this.env <- environment()
while( identical( this.env, globalenv() ) == FALSE ) {
clusterExport(cl,
ls(all.names=TRUE, env=this.env),
envir=this.env)
this.env <- parent.env(environment())
}
## repeat for the global environment
clusterExport(cl,
ls(all.names=TRUE, env=globalenv()),
envir=globalenv())
## Load the libraries on all the clusters
## N.B. length(cl) returns the number of clusters
parLapply( cl, 1:length(cl), function(xx){
lapply(loaded.package.names, function(yy) {
## N.B. the character.only option of
##      require() allows you to give the
##      name of a package as a string.
require(yy , character.only=TRUE)})
})
## Run the lapply in parallel
return( parLapply( cl, ...) )
}, finally = {
## Stop the cluster
stopCluster(cl)
})
}
mclapply.hack(1:4, function(x) return(x^2))
source('~/Documents/tmcmcR/R/mclapply.hack.R')
library(tmcmcR)
library(devtools)
install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
tmcmcR:::tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
mclapply.hack(1:4, function(x) return(x^2))
.Platform$OS.type
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=10;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 2000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
library(tmcmcR)
library(parallel)
tmcmcR:::rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
l <- 1
tmcmcR:::rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
Mult_Mattingly[1,l,,] <- tmcmcR:::rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=10;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 2000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
Mult_Mattingly[1,l,,] <- tmcmcR:::rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
if(is.null(burn_in)) burn_in <- nsamples/3;
if(is.null(scale)) stop("scale value not provided")
if(is.null(beta_set)) stop("set of inverse temperatures not provided")
if(is.null(cycle)) cycle <- ceiling(nsamples*0.01);
rtmc3_chains <- vector("list", length(beta_set));
num = 1
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
num <- 2
.Platform$OS.type == "unix"
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
num = 1
while(num <= nsamples){
if(.Platform$OS.type == "unix"){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=parallel::detectCores()
)
}
else{
chain_set <- mclapply.hack(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(length(temp_chain),0,scale);
temp_chain <- rwmhUpdate(temp_chain,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}
)
}
if(is.null(burn_in)) burn_in <- nsamples/3;
if(is.null(scale)) stop("scale value not provided")
if(is.null(beta_set)) stop("set of inverse temperatures not provided")
if(is.null(cycle)) cycle <- ceiling(nsamples*0.01);
rtmc3_chains <- vector("list", length(beta_set));
num = 1
while(num <= nsamples){
if(.Platform$OS.type == "unix"){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=parallel::detectCores()
)
}
else{
chain_set <- mclapply.hack(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(length(temp_chain),0,scale);
temp_chain <- rwmhUpdate(temp_chain,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}
)
}
rtmc3_chains <- chain_set;
if(num %% cycle ==0)
{
if(swap_adjacent)
{
index_select <- sample(2:length(beta_set), 1);
indices <- c(index_select-1, index_select);
}
if(!swap_adjacent)
{
indices <- sample(1:length(beta_set), 2);
}
chain1 <- rtmc3_chains[[indices[1]]][num,];
chain2 <- rtmc3_chains[[indices[2]]][num,];
swap_rate <- min(1, exp((beta_set[indices[2]] - beta_set[indices[1]])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[indices[1]]][num,] <- chain2;
rtmc3_chains[[indices[2]]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num,"\n");
}
}
num <- num + 1;
}
cycle
cycle=NULL
verb=TRUE
swap_adjacent=TRUE
burn_in=NULL
if(is.null(burn_in)) burn_in <- nsamples/3;
if(is.null(scale)) stop("scale value not provided")
if(is.null(beta_set)) stop("set of inverse temperatures not provided")
if(is.null(cycle)) cycle <- ceiling(nsamples*0.01);
rtmc3_chains <- vector("list", length(beta_set));
num = 1
while(num <= nsamples){
if(.Platform$OS.type == "unix"){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=parallel::detectCores()
)
}
else{
chain_set <- mclapply.hack(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(length(temp_chain),0,scale);
temp_chain <- rwmhUpdate(temp_chain,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}
)
}
rtmc3_chains <- chain_set;
if(num %% cycle ==0)
{
if(swap_adjacent)
{
index_select <- sample(2:length(beta_set), 1);
indices <- c(index_select-1, index_select);
}
if(!swap_adjacent)
{
indices <- sample(1:length(beta_set), 2);
}
chain1 <- rtmc3_chains[[indices[1]]][num,];
chain2 <- rtmc3_chains[[indices[2]]][num,];
swap_rate <- min(1, exp((beta_set[indices[2]] - beta_set[indices[1]])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[indices[1]]][num,] <- chain2;
rtmc3_chains[[indices[2]]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num,"\n");
}
}
num <- num + 1;
}
num <- 1
if(.Platform$OS.type == "unix"){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=parallel::detectCores()
)
}
rtmc3_chains <- chain_set;
if(num %% cycle ==0)
{
if(swap_adjacent)
{
index_select <- sample(2:length(beta_set), 1);
indices <- c(index_select-1, index_select);
}
if(!swap_adjacent)
{
indices <- sample(1:length(beta_set), 2);
}
chain1 <- rtmc3_chains[[indices[1]]][num,];
chain2 <- rtmc3_chains[[indices[2]]][num,];
swap_rate <- min(1, exp((beta_set[indices[2]] - beta_set[indices[1]])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[indices[1]]][num,] <- chain2;
rtmc3_chains[[indices[2]]][num,] <- chain1;
}
}
rtmc3_chains
num <- num + 1;
if(.Platform$OS.type == "unix"){
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=parallel::detectCores()
)
}
num
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1){
chain <- t(as.matrix(base, nrow=1));
out <- chain;
}
if(num > 1)
{
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
}
return(out)
}, mc.cores=parallel::detectCores()
)
k <- 1
temp_chain <- rtmc3_chains[[k]][(num-1),];
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE);
temp_chain <- tmcmcUpdate(temp_chain,b,eps,function(x) return(beta_set[k]*target_pdf(x)))$chain;
out <- rbind(rtmc3_chains[[k]],as.vector(temp_chain));
library(tmcmcR)
devtools::document()
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=10;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 2000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mvtnorm)
library(parallel)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=10);
tmcmcR:::rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]];
system.time(Mult_Mattingly[1,l,,] <- tmcmcR:::rtmc3(pdf,beta_set=beta_set,base=base, scale=1, cycle=20,
swap_adjacent=TRUE, nsamples=2000, verb=FALSE)$chain_set[[1]])
