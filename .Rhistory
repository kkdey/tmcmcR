if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
chain1 <- rtmc3_chains[[k]][num,];
chain1
for(k in 2:length(beta_set))
{
chain1 <- rtmc3_chains[[k]][num,];
chain2 <- rtmc3_chains[[k-1]][num,];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(0,1)
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
}
k
chain1 <- rtmc3_chains[[k]][num,];
chain2 <- rtmc3_chains[[k-1]][num,];
(beta_set[k] - beta_set[(k-1)])
(target_pdf(chain2)-target_pdf(chain1))
target_pdf(chain2)
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
swap_rate
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
devtools::document()
install_github('kkdey/tmcmcR')
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(3,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- adapt_rwmh_metrop(pdf,base=base, nsamples=5000, method="Atchade", verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- adapt_rwmh_metrop(pdf,base=base, nsamples=5000, method="SCAM", verb=FALSE)$chain;
Mult_Mattingly[3,l,,] <- adapt_rwmh_metrop(pdf,base=base, nsamples=5000, method="Rama", verb=FALSE)$chain
cat("We are at iter:",l, "\n")
}
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=10; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=20);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- rtmc3(pdf,beta_set=beta_set,base=base, nsamples=5000, verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- rmc3(pdf,beta_set=beta_set, base=base, nsamples=5000, verb=FALSE)$chain;
}
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
library(tmcmcR)
library(parallel)
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=10; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=20);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- rtmc3(pdf,beta_set=beta_set,base=base, nsamples=5000, verb=FALSE)$chain;
Mult_Mattingly[2,l,,] <- rmc3(pdf,beta_set=beta_set, base=base, nsamples=5000, verb=FALSE)$chain;
}
KSval1=array(0,nsamples);
KSval2=array(0,nsamples);
if(is.null(burn_in)) burn_in <- nsamples/3;
rtmc3_chains <- vector("list", length(beta_set));
num = 1
while(num <= nsamples){
rtmc3_chains <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
for(k in 2:length(beta_set))
{
chain1 <- rtmc3_chains[[k]][num,];
chain2 <- rtmc3_chains[[k-1]][num,];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num);
}
}
num <- num + 1;
}
if(is.null(burn_in)) burn_in <- nsamples/3;
rtmc3_chains <- vector("list", length(beta_set));
num = 1
rtmc3_chains <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
for(k in 2:length(beta_set))
{
chain1 <- rtmc3_chains[[k]][num,];
chain2 <- rtmc3_chains[[k-1]][num,];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
}
num <- num + 1;
rtmc3_chains <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
chain <- rtmc3_chains[[k]][(num-1),];
k <- 1
chain <- rtmc3_chains[[k]][(num-1),];
num
rtmc3_chains[[1]]
num
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
if(is.null(burn_in)) burn_in <- nsamples/3;
rtmc3_chains <- vector("list", length(beta_set));
num = 1
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
for(k in 2:length(beta_set))
{
chain1 <- rtmc3_chains[[k]][num,];
chain2 <- rtmc3_chains[[k-1]][num,];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
}
num <- num + 1;
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
rtmc3_chains[[1]]
rtmc3_chains[[1]][1,]
if(is.null(burn_in)) burn_in <- nsamples/3;
rtmc3_chains <- vector("list", length(beta_set));
num = 1
chain_set <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
out <- rbind(rtmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
rtmc3_chains <- chain_set;
for(k in 2:length(beta_set))
{
chain1 <- rtmc3_chains[[k]][num,];
chain2 <- rtmc3_chains[[k-1]][num,];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rtmc3_chains[[k]][num,] <- chain2;
rtmc3_chains[[k-1]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num);
}
}
rtmc3_chains[[1]]
num <- num +1
k <- 1
chain <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
scale <- 1
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
chain
chain <- tmcmcUpdate(chain,b,eps,target_pdf);
class(chain)
chain <- tmcmcUpdate(as.matrix(chain),b,eps,target_pdf);
chain <- tmcmcUpdate(as.vector(chain),b,eps,target_pdf);
chain <- tmcmcUpdate(chain,b,eps,target_pdf)$chain;
tmcmcUpdate(chain,b,eps,target_pdf)$chain
chain <- rtmc3_chains[[k]][(num-1),];
chain <- tmcmcUpdate(chain,b,eps,target_pdf)$chain;
chain <- rtmc3_chains[[k]][(num-1),];
chain
chain <- rtmc3_chains[[k]][(num-1),];
chain
tmcmcUpdate(as.vector(chain),b,eps,target_pdf)$chain
tmcmcUpdate(as.matrix(chain),b,eps,target_pdf)$chain
tmcmcUpdate(data.frame(chain),b,eps,target_pdf)$chain
tmcmcUpdate(as.numeric(chain),b,eps,target_pdf)$chain
as.numeric(chain)
vec <- tmcmcUpdate(t(chain),b,eps,target_pdf)$chain;
vec
vec <- tmcmcUpdate(t(as.matrix(chain)),b,eps,target_pdf)$chain;
chain1 <- rtmc3_chains[[k]][(num-1),];
vec <- tmcmcUpdate(t(as.matrix(chain1)),b,eps,target_pdf)$chain;
vec <- tmcmcUpdate(chain1,b,eps,target_pdf)$chain;
chain1 <- rtmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
scale
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE)
vec <- tmcmcUpdate(chain1,b,eps,target_pdf)$chain;
tmcmcUpdate(base,b,eps,target_pdf)$chain
library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
for ( l in 1:L)
{
Mult_Mattingly[1,l,,] <- tmcmc_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
Mult_Mattingly[2,l,,] <- rwmh_metrop(pdf,base=base, scale=1,nsamples=5000,burn_in = NULL)$chain;
cat("We are at iter:",l, "\n")
}
library(devtools)
#install_github('kkdey/tmcmcR')
library(tmcmcR)
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=10; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(3,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
beta_set <- seq(1,0.05,length.out=20);
beta_set
target_pdf <- pdf
if(is.null(burn_in)) burn_in <- nsamples/3;
rmc3_chains <- vector("list", length(beta_set));
num = 1
rmc3_chains <- parallel::mclapply(1:length(beta_set),
function(k){
if(num==1)
chain <- t(as.matrix(base, nrow=1));
out <- chain;
if(num > 1)
{
chain <- rmc3_chains[[k]][(num-1),];
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain <- rwmhUpdate(chain,b,eps,target_pdf);
out <- rbind(rmc3_chains[[k]],chain);
}
return(out)
}, mc.cores=detectCores()
)
for(k in 2:length(beta_set))
{
chain1 <- rmc3_chains[[k]][num,];
chain2 <- rmc3_chains[[k-1]][num,];
swap_rate <- min(1, exp((beta_set[k] - beta_set[(k-1)])*(target_pdf(chain2)-target_pdf(chain1))));
w <- runif(1,0,1)
if(w < swap_rate){
rmc3_chains[[k]][num,] <- chain2;
rmc3_chains[[k-1]][num,] <- chain1;
}
}
if(num %% 500 ==0){
if(verb){
cat("The chain is at iteration:",num);
}
}
num <- num + 1;
rmc3_chains[[1]]
dim(rmc3_chains[[1]])
rmc3_chains[[1]]
dim(rmc3_chains[[1]])
chain <- rmc3_chains[[k]][(num-1),];
chain
eps <- abs(rnorm(1,0,scale));
b <- sample(c(-1,+1),length(base),replace=TRUE)
b
rwmhUpdate(chain,b,eps,target_pdf)
eps <- rnorm(length(chain),0,scale));
eps <- rnorm(length(chain),0,scale);
eps
rwmhUpdate(chain,eps,target_pdf)
rwmhUpdate(rep(0,length(eps)),eps,target_pdf)
eps
class(eps)
rwmhUpdate(rep(0,length(eps)),eps,target_pdf)
tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)
chain <- matrix(0, nsamples, length(base))
chain[1,] <- base;
num <- 2
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain[num,] <- tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)$chain;
tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)
target_pdf()
target_pdf
chain[(num-1),]
b
eps
tmcmcUpdate()
help(tmcmcUpdate)
??tmcmcUpdate
library(devtools)
install_github('kkdey/tmcmcR')
library(mcmc)
d=50;  ##  dimension of the simulated variable
L=30; ###   the number of replications we use for finding KS statistic
nsamples <- 5000;
Mult_Mattingly=array(0,c(2,L,nsamples,d));
mu_target=rep(0,d);
Sigma_target = 0.01*diag(1/(1:(d))*d);
L=30; ###   the number of replications we use for finding KS statistic
Mult_Mattingly=array(0,c(2,L,nsamples,d));
Mattingly_matrix <- 100*(diag(1-0.7,d)+0.7*rep(1,d)%*%t(rep(1,d)));
library(mnormt)
library(fMultivar)
library(mvtnorm)
pdf = function(x)
{
return (dmvnorm(x,mu_target,Sigma_target,log=TRUE)-t(x)%*%Mattingly_matrix%*%x)
}
base=rnorm(d,0,1);
target_pdf <- pdf
target_pdf
if(is.null(burn_in)) burn_in <- nsamples/3;
chain <- matrix(0, nsamples, length(base))
chain[1,] <- base;
num <- 2
eps <- rnorm(1,0,scale);
b <- sample(c(-1,+1),length(base),replace=TRUE)
chain[num,] <- tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)$chain;
num
tmcmcUpdate(chain[(num-1),],b,eps,target_pdf)$chain
